# httper

[![travis Status](https://travis-ci.org//mh-cbon/httper.svg?branch=master)](https://travis-ci.org//mh-cbon/httper) [![Appveyor Status](https://ci.appveyor.com/api/projects/status//github/mh-cbon/httper?branch=master&svg=true)](https://ci.appveyor.com/projects//mh-cbon/httper) [![Go Report Card](https://goreportcard.com/badge/github.com/mh-cbon/httper)](https://goreportcard.com/report/github.com/mh-cbon/httper) [![GoDoc](https://godoc.org/github.com/mh-cbon/httper?status.svg)](http://godoc.org/github.com/mh-cbon/httper) [![MIT License](http://img.shields.io/badge/License-MIT-yellow.svg)](LICENSE)

Package httper is a cli tool to implement http interface of a type.


Choose your gun! | [Aux armes!](https://www.youtube.com/watch?v=hD-wD_AMRYc&t=7)

# TOC
- [Install](#install)
  - [glide](#glide)
- [Usage](#usage)
  - [$ httper -help](#-httper--help)
- [Cli examples](#cli-examples)
- [API example](#api-example)
  - [> demo/main.go](#-demomaingo)
  - [> demo/http_vegetables_gen.go](#-demohttp_vegetables_gengo)
- [Recipes](#recipes)
  - [Release the project](#release-the-project)
- [History](#history)

# Install

#### glide
```sh
mkdir -p $GOPATH/src/github.com/mh-cbon/httper
cd $GOPATH/src/github.com/mh-cbon/httper
git clone https://github.com/mh-cbon/httper.git .
glide install
go install
```


# Usage

#### $ httper -help
```sh
httper 0.0.0

Usage

	httper [-p name] [out] [...types]

	out:   Output destination of the results, use '-' for stdout.
	types: A list of types such as src:dst.
	-p:    The name of the package output.
```

## Cli examples

```sh
# Create a httped version of Tomate to MyTomate
httper http_vegetables_gen.go *JSONTomates:HTTPTomates
```

# API example

Following example demonstates a program using it to generate an `httped` version of a type.

#### > demo/main.go
```go
package main

import (
	"log"
	"net/http"
)

//go:generate lister vegetables_gen.go *Tomate:Tomates
//go:generate channeler tomate_chan_gen.go *Tomates:ChanTomates

//go:generate jsoner json_controller_gen.go *Controller:JSONController
//go:generate httper http_vegetables_gen.go *JSONController:HTTPController

func main() {

	backend := NewChanTomates()
	backend.Push(&Tomate{Name: "red"})

	jsoner := NewJSONController(NewController(backend))
	httper := NewHTTPController(jsoner)

	// public views
	http.HandleFunc("/", httper.GetByID)

	/*
		curl -H "Accept: application/json" -H "Content-type: application/json"  http://localhost:8080/?id=0
	*/

	log.Fatal(http.ListenAndServe(":8080", nil))
}

// Tomate is about red vegetables to make famous italian food.
type Tomate struct {
	ID   int
	Name string
}

// GetID return the ID of the Tomate.
func (t *Tomate) GetID() int {
	return t.ID
}

// Controller of some resources.
type Controller struct {
	backend *ChanTomates
}

// NewController ...
func NewController(backend *ChanTomates) *Controller {
	return &Controller{
		backend: backend,
	}
}

// GetByID ...
func (t *Controller) GetByID(urlID int) *Tomate {
	return t.backend.Filter(FilterTomates.ByID(urlID)).First()
}

// UpdateByID ...
func (t *Controller) UpdateByID(urlID int, reqBody *Tomate) *Tomate {
	t.backend.Filter(func(v *Tomate) bool {
		if v.ID == urlID {
			v.Name = reqBody.Name
		}
		return true
	})
	return reqBody
}

// DeleteByID ...
func (t *Controller) DeleteByID(reqID int) bool {
	return t.backend.Remove(&Tomate{ID: reqID})
}
```

Following code is the generated implementation of an `httped` typed slice of `Tomate`.

#### > demo/http_vegetables_gen.go
```go
package main

// file generated by
// github.com/mh-cbon/httper
// do not edit

import (
	"io"
	"net/http"
	"strconv"
)

var xxStrconvAtoi = strconv.Atoi
var xxIoCopy = io.Copy
var xxHTTPOk = http.StatusOK

// HTTPController is an httper of *JSONController.
type HTTPController struct {
	embed *JSONController
}

// NewHTTPController constructs an httper of *JSONController
func NewHTTPController(embed *JSONController) *HTTPController {
	ret := &HTTPController{
		embed: embed,
	}
	return ret
}

// GetByID invoke *JSONController.GetByID using the request body as a json payload.
func (t *HTTPController) GetByID(w http.ResponseWriter, r *http.Request) {

	var urlID int
	urlID, err := strconv.Atoi(r.URL.Query().Get("ID"))
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError) // todo: not static.
		io.WriteString(w, err.Error())                // todo: not static.
		return
	}
	res, err := t.embed.GetByID(urlID)

	if err != nil {
		w.WriteHeader(http.StatusInternalServerError) // todo: not static.
		io.WriteString(w, err.Error())                // todo: not static.
		return
	}

	w.WriteHeader(http.StatusOK)
	w.Header().Set("Content-Type", "application/json") // todo: not static.
	io.Copy(w, res)

}

// UpdateByID invoke *JSONController.UpdateByID using the request body as a json payload.
func (t *HTTPController) UpdateByID(w http.ResponseWriter, r *http.Request) {

	var urlID int
	urlID, err := strconv.Atoi(r.URL.Query().Get("ID"))
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError) // todo: not static.
		io.WriteString(w, err.Error())                // todo: not static.
		return
	}
	reqBody := r.Body
	res, err := t.embed.UpdateByID(urlID, reqBody)

	if err != nil {
		w.WriteHeader(http.StatusInternalServerError) // todo: not static.
		io.WriteString(w, err.Error())                // todo: not static.
		return
	}

	w.WriteHeader(http.StatusOK)
	w.Header().Set("Content-Type", "application/json") // todo: not static.
	io.Copy(w, res)

}

// DeleteByID invoke *JSONController.DeleteByID using the request body as a json payload.
func (t *HTTPController) DeleteByID(w http.ResponseWriter, r *http.Request) {

	var reqID int
	reqID, err := strconv.Atoi(r.URL.Query().Get("ID"))
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError) // todo: not static.
		io.WriteString(w, err.Error())                // todo: not static.
		return
	}
	if reqID == "" {
		err = r.ParseForm()
		if err != nil {
			w.WriteHeader(http.StatusInternalServerError) // todo: not static.
			io.WriteString(w, err.Error())                // todo: not static.
			return
		}
		reqID = r.FormValue("ID")
	}
	res, err := t.embed.DeleteByID(reqID)

	if err != nil {
		w.WriteHeader(http.StatusInternalServerError) // todo: not static.
		io.WriteString(w, err.Error())                // todo: not static.
		return
	}

	w.WriteHeader(http.StatusOK)
	w.Header().Set("Content-Type", "application/json") // todo: not static.
	io.Copy(w, res)

}
```

# Recipes

#### Release the project

```sh
gump patch -d # check
gump patch # bump
```

# History

[CHANGELOG](CHANGELOG.md)
