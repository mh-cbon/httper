# httper

[![travis Status](https://travis-ci.org//mh-cbon/httper.svg?branch=master)](https://travis-ci.org//mh-cbon/httper) [![Appveyor Status](https://ci.appveyor.com/api/projects/status//github/mh-cbon/httper?branch=master&svg=true)](https://ci.appveyor.com/projects//mh-cbon/httper) [![Go Report Card](https://goreportcard.com/badge/github.com/mh-cbon/httper)](https://goreportcard.com/report/github.com/mh-cbon/httper) [![GoDoc](https://godoc.org/github.com/mh-cbon/httper?status.svg)](http://godoc.org/github.com/mh-cbon/httper) [![MIT License](http://img.shields.io/badge/License-MIT-yellow.svg)](LICENSE)

Package httper is a cli tool to implement http interface of a type.


Choose your gun! | [Aux armes!](https://www.youtube.com/watch?v=hD-wD_AMRYc&t=7)

# TOC
- [Install](#install)
  - [glide](#glide)
- [Usage](#usage)
  - [$ httper -help](#-httper--help)
- [Cli examples](#cli-examples)
- [API example](#api-example)
  - [> demo/main.go](#-demomaingo)
  - [> demo/http_vegetables_gen.go](#-demohttp_vegetables_gengo)
- [Recipes](#recipes)
  - [Release the project](#release-the-project)
- [History](#history)

# Install

#### glide
```sh
mkdir -p $GOPATH/src/github.com/mh-cbon/httper
cd $GOPATH/src/github.com/mh-cbon/httper
git clone https://github.com/mh-cbon/httper.git .
glide install
go install
```


# Usage

#### $ httper -help
```sh
httper 0.0.0

Usage

	httper [-p name] [out] [...types]

	out:   Output destination of the results, use '-' for stdout.
	types: A list of types such as src:dst.
	-p:    The name of the package output.
```

## Cli examples

```sh
# Create a channeled version of Tomate to MyTomate
httper http_vegetables_gen.go *JSONTomates:HTTPTomates
```

# API example

Following example demonstates a program using it to generate an `httped` version of a type.

#### > demo/main.go
```go
package main

import (
	"log"
	"net/http"
)

// Tomate is about red vegetables to make famous italian food.
type Tomate struct {
	Name string
}

// GetID return the ID of the Tomate.
func (t Tomate) GetID() string {
	return t.Name
}

//go:generate lister vegetables_gen.go Tomate:Tomates
//go:generate jsoner json_vegetables_gen.go *Tomates:JSONTomates
//go:generate httper http_vegetables_gen.go *JSONTomates:HTTPTomates

func main() {

	backend := NewTomates()
	backend.Push(Tomate{Name: "red"})
	jsoner := NewJSONTomates(backend)
	httper := NewHTTPTomates(jsoner)

	// public views
	http.HandleFunc("/", httper.At)

	/*
		curl -H "Accept: application/json" -H "Content-type: application/json" -X POST -d ' {"i":0}'  http://localhost:8080/
	*/

	log.Fatal(http.ListenAndServe(":8080", nil))
}
```

Following code is the generated implementation of an `httped` typed slice of `Tomate`.

#### > demo/http_vegetables_gen.go
```go
package main

// file generated by
// github.com.mh-cbon/httper
// do not edit

import (
	"io"
	"net/http"
)

// HTTPTomates is an httper of *JSONTomates.
type HTTPTomates struct {
	embed *JSONTomates
}

// NewHTTPTomates constructs an httper of *JSONTomates
func NewHTTPTomates(embed *JSONTomates) *HTTPTomates {
	ret := &HTTPTomates{
		embed: embed,
	}
	return ret
}

// Push invoke *JSONTomates.Push using the request body as a json payload.
func (t *HTTPTomates) Push(w http.ResponseWriter, r *http.Request) {
	res, err := t.embed.Push(r.Body)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError) // todo: not static.
		io.WriteString(w, err.Error())                // todo: not static.
	} else {
		w.WriteHeader(http.StatusOK)
		w.Header().Set("Content-Type", "application/json") // todo: not static.
		io.Copy(w, res)
	}
}

// Unshift invoke *JSONTomates.Unshift using the request body as a json payload.
func (t *HTTPTomates) Unshift(w http.ResponseWriter, r *http.Request) {
	res, err := t.embed.Unshift(r.Body)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError) // todo: not static.
		io.WriteString(w, err.Error())                // todo: not static.
	} else {
		w.WriteHeader(http.StatusOK)
		w.Header().Set("Content-Type", "application/json") // todo: not static.
		io.Copy(w, res)
	}
}

// Pop invoke *JSONTomates.Pop using the request body as a json payload.
func (t *HTTPTomates) Pop(w http.ResponseWriter, r *http.Request) {
	res, err := t.embed.Pop(r.Body)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError) // todo: not static.
		io.WriteString(w, err.Error())                // todo: not static.
	} else {
		w.WriteHeader(http.StatusOK)
		w.Header().Set("Content-Type", "application/json") // todo: not static.
		io.Copy(w, res)
	}
}

// Shift invoke *JSONTomates.Shift using the request body as a json payload.
func (t *HTTPTomates) Shift(w http.ResponseWriter, r *http.Request) {
	res, err := t.embed.Shift(r.Body)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError) // todo: not static.
		io.WriteString(w, err.Error())                // todo: not static.
	} else {
		w.WriteHeader(http.StatusOK)
		w.Header().Set("Content-Type", "application/json") // todo: not static.
		io.Copy(w, res)
	}
}

// Index invoke *JSONTomates.Index using the request body as a json payload.
func (t *HTTPTomates) Index(w http.ResponseWriter, r *http.Request) {
	res, err := t.embed.Index(r.Body)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError) // todo: not static.
		io.WriteString(w, err.Error())                // todo: not static.
	} else {
		w.WriteHeader(http.StatusOK)
		w.Header().Set("Content-Type", "application/json") // todo: not static.
		io.Copy(w, res)
	}
}

// Contains invoke *JSONTomates.Contains using the request body as a json payload.
func (t *HTTPTomates) Contains(w http.ResponseWriter, r *http.Request) {
	res, err := t.embed.Contains(r.Body)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError) // todo: not static.
		io.WriteString(w, err.Error())                // todo: not static.
	} else {
		w.WriteHeader(http.StatusOK)
		w.Header().Set("Content-Type", "application/json") // todo: not static.
		io.Copy(w, res)
	}
}

// RemoveAt invoke *JSONTomates.RemoveAt using the request body as a json payload.
func (t *HTTPTomates) RemoveAt(w http.ResponseWriter, r *http.Request) {
	res, err := t.embed.RemoveAt(r.Body)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError) // todo: not static.
		io.WriteString(w, err.Error())                // todo: not static.
	} else {
		w.WriteHeader(http.StatusOK)
		w.Header().Set("Content-Type", "application/json") // todo: not static.
		io.Copy(w, res)
	}
}

// Remove invoke *JSONTomates.Remove using the request body as a json payload.
func (t *HTTPTomates) Remove(w http.ResponseWriter, r *http.Request) {
	res, err := t.embed.Remove(r.Body)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError) // todo: not static.
		io.WriteString(w, err.Error())                // todo: not static.
	} else {
		w.WriteHeader(http.StatusOK)
		w.Header().Set("Content-Type", "application/json") // todo: not static.
		io.Copy(w, res)
	}
}

// InsertAt invoke *JSONTomates.InsertAt using the request body as a json payload.
func (t *HTTPTomates) InsertAt(w http.ResponseWriter, r *http.Request) {
	res, err := t.embed.InsertAt(r.Body)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError) // todo: not static.
		io.WriteString(w, err.Error())                // todo: not static.
	} else {
		w.WriteHeader(http.StatusOK)
		w.Header().Set("Content-Type", "application/json") // todo: not static.
		io.Copy(w, res)
	}
}

// Splice invoke *JSONTomates.Splice using the request body as a json payload.
func (t *HTTPTomates) Splice(w http.ResponseWriter, r *http.Request) {
	res, err := t.embed.Splice(r.Body)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError) // todo: not static.
		io.WriteString(w, err.Error())                // todo: not static.
	} else {
		w.WriteHeader(http.StatusOK)
		w.Header().Set("Content-Type", "application/json") // todo: not static.
		io.Copy(w, res)
	}
}

// Slice invoke *JSONTomates.Slice using the request body as a json payload.
func (t *HTTPTomates) Slice(w http.ResponseWriter, r *http.Request) {
	res, err := t.embed.Slice(r.Body)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError) // todo: not static.
		io.WriteString(w, err.Error())                // todo: not static.
	} else {
		w.WriteHeader(http.StatusOK)
		w.Header().Set("Content-Type", "application/json") // todo: not static.
		io.Copy(w, res)
	}
}

// Reverse invoke *JSONTomates.Reverse using the request body as a json payload.
func (t *HTTPTomates) Reverse(w http.ResponseWriter, r *http.Request) {
	res, err := t.embed.Reverse(r.Body)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError) // todo: not static.
		io.WriteString(w, err.Error())                // todo: not static.
	} else {
		w.WriteHeader(http.StatusOK)
		w.Header().Set("Content-Type", "application/json") // todo: not static.
		io.Copy(w, res)
	}
}

// Len invoke *JSONTomates.Len using the request body as a json payload.
func (t *HTTPTomates) Len(w http.ResponseWriter, r *http.Request) {
	res, err := t.embed.Len(r.Body)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError) // todo: not static.
		io.WriteString(w, err.Error())                // todo: not static.
	} else {
		w.WriteHeader(http.StatusOK)
		w.Header().Set("Content-Type", "application/json") // todo: not static.
		io.Copy(w, res)
	}
}

// Set invoke *JSONTomates.Set using the request body as a json payload.
func (t *HTTPTomates) Set(w http.ResponseWriter, r *http.Request) {
	res, err := t.embed.Set(r.Body)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError) // todo: not static.
		io.WriteString(w, err.Error())                // todo: not static.
	} else {
		w.WriteHeader(http.StatusOK)
		w.Header().Set("Content-Type", "application/json") // todo: not static.
		io.Copy(w, res)
	}
}

// Get invoke *JSONTomates.Get using the request body as a json payload.
func (t *HTTPTomates) Get(w http.ResponseWriter, r *http.Request) {
	res, err := t.embed.Get(r.Body)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError) // todo: not static.
		io.WriteString(w, err.Error())                // todo: not static.
	} else {
		w.WriteHeader(http.StatusOK)
		w.Header().Set("Content-Type", "application/json") // todo: not static.
		io.Copy(w, res)
	}
}

// At invoke *JSONTomates.At using the request body as a json payload.
func (t *HTTPTomates) At(w http.ResponseWriter, r *http.Request) {
	res, err := t.embed.At(r.Body)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError) // todo: not static.
		io.WriteString(w, err.Error())                // todo: not static.
	} else {
		w.WriteHeader(http.StatusOK)
		w.Header().Set("Content-Type", "application/json") // todo: not static.
		io.Copy(w, res)
	}
}

// Filter invoke *JSONTomates.Filter using the request body as a json payload.
func (t *HTTPTomates) Filter(w http.ResponseWriter, r *http.Request) {
	res, err := t.embed.Filter(r.Body)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError) // todo: not static.
		io.WriteString(w, err.Error())                // todo: not static.
	} else {
		w.WriteHeader(http.StatusOK)
		w.Header().Set("Content-Type", "application/json") // todo: not static.
		io.Copy(w, res)
	}
}

// First invoke *JSONTomates.First using the request body as a json payload.
func (t *HTTPTomates) First(w http.ResponseWriter, r *http.Request) {
	res, err := t.embed.First(r.Body)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError) // todo: not static.
		io.WriteString(w, err.Error())                // todo: not static.
	} else {
		w.WriteHeader(http.StatusOK)
		w.Header().Set("Content-Type", "application/json") // todo: not static.
		io.Copy(w, res)
	}
}

// Last invoke *JSONTomates.Last using the request body as a json payload.
func (t *HTTPTomates) Last(w http.ResponseWriter, r *http.Request) {
	res, err := t.embed.Last(r.Body)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError) // todo: not static.
		io.WriteString(w, err.Error())                // todo: not static.
	} else {
		w.WriteHeader(http.StatusOK)
		w.Header().Set("Content-Type", "application/json") // todo: not static.
		io.Copy(w, res)
	}
}

// Empty invoke *JSONTomates.Empty using the request body as a json payload.
func (t *HTTPTomates) Empty(w http.ResponseWriter, r *http.Request) {
	res, err := t.embed.Empty(r.Body)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError) // todo: not static.
		io.WriteString(w, err.Error())                // todo: not static.
	} else {
		w.WriteHeader(http.StatusOK)
		w.Header().Set("Content-Type", "application/json") // todo: not static.
		io.Copy(w, res)
	}
}
```

# Recipes

#### Release the project

```sh
gump patch -d # check
gump patch # bump
```

# History

[CHANGELOG](CHANGELOG.md)
