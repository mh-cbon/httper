package main

// file generated by
// github.com.mh-cbon/httper
// do not edit

import (
	"io"
	"net/http"
)

// HTTPTomates is an httper of *JSONTomates.
type HTTPTomates struct {
	embed *JSONTomates
}

// NewHTTPTomates constructs an httper of *JSONTomates
func NewHTTPTomates(embed *JSONTomates) *HTTPTomates {
	ret := &HTTPTomates{
		embed: embed,
	}
	return ret
}

// Push invoke *JSONTomates.Push using the request body as a json payload.
func (t *HTTPTomates) Push(w http.ResponseWriter, r *http.Request) {
	res, err := t.embed.Push(r.Body)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError) // todo: not static.
		io.WriteString(w, err.Error())                // todo: not static.
	} else {
		w.WriteHeader(http.StatusOK)
		w.Header().Set("Content-Type", "application/json") // todo: not static.
		io.Copy(w, res)
	}
}

// Unshift invoke *JSONTomates.Unshift using the request body as a json payload.
func (t *HTTPTomates) Unshift(w http.ResponseWriter, r *http.Request) {
	res, err := t.embed.Unshift(r.Body)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError) // todo: not static.
		io.WriteString(w, err.Error())                // todo: not static.
	} else {
		w.WriteHeader(http.StatusOK)
		w.Header().Set("Content-Type", "application/json") // todo: not static.
		io.Copy(w, res)
	}
}

// Pop invoke *JSONTomates.Pop using the request body as a json payload.
func (t *HTTPTomates) Pop(w http.ResponseWriter, r *http.Request) {
	res, err := t.embed.Pop(r.Body)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError) // todo: not static.
		io.WriteString(w, err.Error())                // todo: not static.
	} else {
		w.WriteHeader(http.StatusOK)
		w.Header().Set("Content-Type", "application/json") // todo: not static.
		io.Copy(w, res)
	}
}

// Shift invoke *JSONTomates.Shift using the request body as a json payload.
func (t *HTTPTomates) Shift(w http.ResponseWriter, r *http.Request) {
	res, err := t.embed.Shift(r.Body)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError) // todo: not static.
		io.WriteString(w, err.Error())                // todo: not static.
	} else {
		w.WriteHeader(http.StatusOK)
		w.Header().Set("Content-Type", "application/json") // todo: not static.
		io.Copy(w, res)
	}
}

// Index invoke *JSONTomates.Index using the request body as a json payload.
func (t *HTTPTomates) Index(w http.ResponseWriter, r *http.Request) {
	res, err := t.embed.Index(r.Body)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError) // todo: not static.
		io.WriteString(w, err.Error())                // todo: not static.
	} else {
		w.WriteHeader(http.StatusOK)
		w.Header().Set("Content-Type", "application/json") // todo: not static.
		io.Copy(w, res)
	}
}

// Contains invoke *JSONTomates.Contains using the request body as a json payload.
func (t *HTTPTomates) Contains(w http.ResponseWriter, r *http.Request) {
	res, err := t.embed.Contains(r.Body)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError) // todo: not static.
		io.WriteString(w, err.Error())                // todo: not static.
	} else {
		w.WriteHeader(http.StatusOK)
		w.Header().Set("Content-Type", "application/json") // todo: not static.
		io.Copy(w, res)
	}
}

// RemoveAt invoke *JSONTomates.RemoveAt using the request body as a json payload.
func (t *HTTPTomates) RemoveAt(w http.ResponseWriter, r *http.Request) {
	res, err := t.embed.RemoveAt(r.Body)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError) // todo: not static.
		io.WriteString(w, err.Error())                // todo: not static.
	} else {
		w.WriteHeader(http.StatusOK)
		w.Header().Set("Content-Type", "application/json") // todo: not static.
		io.Copy(w, res)
	}
}

// Remove invoke *JSONTomates.Remove using the request body as a json payload.
func (t *HTTPTomates) Remove(w http.ResponseWriter, r *http.Request) {
	res, err := t.embed.Remove(r.Body)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError) // todo: not static.
		io.WriteString(w, err.Error())                // todo: not static.
	} else {
		w.WriteHeader(http.StatusOK)
		w.Header().Set("Content-Type", "application/json") // todo: not static.
		io.Copy(w, res)
	}
}

// InsertAt invoke *JSONTomates.InsertAt using the request body as a json payload.
func (t *HTTPTomates) InsertAt(w http.ResponseWriter, r *http.Request) {
	res, err := t.embed.InsertAt(r.Body)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError) // todo: not static.
		io.WriteString(w, err.Error())                // todo: not static.
	} else {
		w.WriteHeader(http.StatusOK)
		w.Header().Set("Content-Type", "application/json") // todo: not static.
		io.Copy(w, res)
	}
}

// Splice invoke *JSONTomates.Splice using the request body as a json payload.
func (t *HTTPTomates) Splice(w http.ResponseWriter, r *http.Request) {
	res, err := t.embed.Splice(r.Body)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError) // todo: not static.
		io.WriteString(w, err.Error())                // todo: not static.
	} else {
		w.WriteHeader(http.StatusOK)
		w.Header().Set("Content-Type", "application/json") // todo: not static.
		io.Copy(w, res)
	}
}

// Slice invoke *JSONTomates.Slice using the request body as a json payload.
func (t *HTTPTomates) Slice(w http.ResponseWriter, r *http.Request) {
	res, err := t.embed.Slice(r.Body)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError) // todo: not static.
		io.WriteString(w, err.Error())                // todo: not static.
	} else {
		w.WriteHeader(http.StatusOK)
		w.Header().Set("Content-Type", "application/json") // todo: not static.
		io.Copy(w, res)
	}
}

// Reverse invoke *JSONTomates.Reverse using the request body as a json payload.
func (t *HTTPTomates) Reverse(w http.ResponseWriter, r *http.Request) {
	res, err := t.embed.Reverse(r.Body)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError) // todo: not static.
		io.WriteString(w, err.Error())                // todo: not static.
	} else {
		w.WriteHeader(http.StatusOK)
		w.Header().Set("Content-Type", "application/json") // todo: not static.
		io.Copy(w, res)
	}
}

// Len invoke *JSONTomates.Len using the request body as a json payload.
func (t *HTTPTomates) Len(w http.ResponseWriter, r *http.Request) {
	res, err := t.embed.Len(r.Body)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError) // todo: not static.
		io.WriteString(w, err.Error())                // todo: not static.
	} else {
		w.WriteHeader(http.StatusOK)
		w.Header().Set("Content-Type", "application/json") // todo: not static.
		io.Copy(w, res)
	}
}

// Set invoke *JSONTomates.Set using the request body as a json payload.
func (t *HTTPTomates) Set(w http.ResponseWriter, r *http.Request) {
	res, err := t.embed.Set(r.Body)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError) // todo: not static.
		io.WriteString(w, err.Error())                // todo: not static.
	} else {
		w.WriteHeader(http.StatusOK)
		w.Header().Set("Content-Type", "application/json") // todo: not static.
		io.Copy(w, res)
	}
}

// Get invoke *JSONTomates.Get using the request body as a json payload.
func (t *HTTPTomates) Get(w http.ResponseWriter, r *http.Request) {
	res, err := t.embed.Get(r.Body)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError) // todo: not static.
		io.WriteString(w, err.Error())                // todo: not static.
	} else {
		w.WriteHeader(http.StatusOK)
		w.Header().Set("Content-Type", "application/json") // todo: not static.
		io.Copy(w, res)
	}
}

// At invoke *JSONTomates.At using the request body as a json payload.
func (t *HTTPTomates) At(w http.ResponseWriter, r *http.Request) {
	res, err := t.embed.At(r.Body)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError) // todo: not static.
		io.WriteString(w, err.Error())                // todo: not static.
	} else {
		w.WriteHeader(http.StatusOK)
		w.Header().Set("Content-Type", "application/json") // todo: not static.
		io.Copy(w, res)
	}
}

// Filter invoke *JSONTomates.Filter using the request body as a json payload.
func (t *HTTPTomates) Filter(w http.ResponseWriter, r *http.Request) {
	res, err := t.embed.Filter(r.Body)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError) // todo: not static.
		io.WriteString(w, err.Error())                // todo: not static.
	} else {
		w.WriteHeader(http.StatusOK)
		w.Header().Set("Content-Type", "application/json") // todo: not static.
		io.Copy(w, res)
	}
}

// First invoke *JSONTomates.First using the request body as a json payload.
func (t *HTTPTomates) First(w http.ResponseWriter, r *http.Request) {
	res, err := t.embed.First(r.Body)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError) // todo: not static.
		io.WriteString(w, err.Error())                // todo: not static.
	} else {
		w.WriteHeader(http.StatusOK)
		w.Header().Set("Content-Type", "application/json") // todo: not static.
		io.Copy(w, res)
	}
}

// Last invoke *JSONTomates.Last using the request body as a json payload.
func (t *HTTPTomates) Last(w http.ResponseWriter, r *http.Request) {
	res, err := t.embed.Last(r.Body)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError) // todo: not static.
		io.WriteString(w, err.Error())                // todo: not static.
	} else {
		w.WriteHeader(http.StatusOK)
		w.Header().Set("Content-Type", "application/json") // todo: not static.
		io.Copy(w, res)
	}
}

// Empty invoke *JSONTomates.Empty using the request body as a json payload.
func (t *HTTPTomates) Empty(w http.ResponseWriter, r *http.Request) {
	res, err := t.embed.Empty(r.Body)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError) // todo: not static.
		io.WriteString(w, err.Error())                // todo: not static.
	} else {
		w.WriteHeader(http.StatusOK)
		w.Header().Set("Content-Type", "application/json") // todo: not static.
		io.Copy(w, res)
	}
}
