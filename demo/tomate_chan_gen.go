package main

// file generated by
// github.com.mh-cbon/channeler
// do not edit

// ChanTomates is channeled.
type ChanTomates struct {
	embed *Tomates
	ops   chan func()
	stop  chan bool
	tick  chan bool
}

// NewChanTomates constructs a chenneled version of *Tomates
func NewChanTomates() *ChanTomates {
	ret := &ChanTomates{
		ops:  make(chan func()),
		tick: make(chan bool),
		stop: make(chan bool),
	}
	ret.embed = NewTomates()
	go ret.Start()
	return ret
}

// Start the main loop
func (t *ChanTomates) Start() {
	for {
		select {
		case op := <-t.ops:
			op()
			t.tick <- true
		case <-t.stop:
			return
		}
	}
}

// Stop the main loop
func (t *ChanTomates) Stop() {
	t.stop <- true
}

// Push is channeled
func (t *ChanTomates) Push(x ...*Tomate) *Tomates {
	var retVar0 *Tomates
	t.ops <- func() {
		retVar0 = t.embed.Push(x...)
	}
	<-t.tick
	return retVar0
}

// Unshift is channeled
func (t *ChanTomates) Unshift(x ...*Tomate) *Tomates {
	var retVar1 *Tomates
	t.ops <- func() {
		retVar1 = t.embed.Unshift(x...)
	}
	<-t.tick
	return retVar1
}

// Pop is channeled
func (t *ChanTomates) Pop() *Tomate {
	var retVar2 *Tomate
	t.ops <- func() {
		retVar2 = t.embed.Pop()
	}
	<-t.tick
	return retVar2
}

// Shift is channeled
func (t *ChanTomates) Shift() *Tomate {
	var retVar3 *Tomate
	t.ops <- func() {
		retVar3 = t.embed.Shift()
	}
	<-t.tick
	return retVar3
}

// Index is channeled
func (t *ChanTomates) Index(s *Tomate) int {
	var retVar4 int
	t.ops <- func() {
		retVar4 = t.embed.Index(s)
	}
	<-t.tick
	return retVar4
}

// Contains is channeled
func (t *ChanTomates) Contains(s *Tomate) bool {
	var retVar5 bool
	t.ops <- func() {
		retVar5 = t.embed.Contains(s)
	}
	<-t.tick
	return retVar5
}

// RemoveAt is channeled
func (t *ChanTomates) RemoveAt(i int) bool {
	var retVar6 bool
	t.ops <- func() {
		retVar6 = t.embed.RemoveAt(i)
	}
	<-t.tick
	return retVar6
}

// Remove is channeled
func (t *ChanTomates) Remove(s *Tomate) bool {
	var retVar7 bool
	t.ops <- func() {
		retVar7 = t.embed.Remove(s)
	}
	<-t.tick
	return retVar7
}

// InsertAt is channeled
func (t *ChanTomates) InsertAt(i int, s *Tomate) *Tomates {
	var retVar8 *Tomates
	t.ops <- func() {
		retVar8 = t.embed.InsertAt(i, s)
	}
	<-t.tick
	return retVar8
}

// Splice is channeled
func (t *ChanTomates) Splice(start int, length int, s ...*Tomate) []*Tomate {
	var retVar9 []*Tomate
	t.ops <- func() {
		retVar9 = t.embed.Splice(start, length, s...)
	}
	<-t.tick
	return retVar9
}

// Slice is channeled
func (t *ChanTomates) Slice(start int, length int) []*Tomate {
	var retVar10 []*Tomate
	t.ops <- func() {
		retVar10 = t.embed.Slice(start, length)
	}
	<-t.tick
	return retVar10
}

// Reverse is channeled
func (t *ChanTomates) Reverse() *Tomates {
	var retVar11 *Tomates
	t.ops <- func() {
		retVar11 = t.embed.Reverse()
	}
	<-t.tick
	return retVar11
}

// Len is channeled
func (t *ChanTomates) Len() int {
	var retVar12 int
	t.ops <- func() {
		retVar12 = t.embed.Len()
	}
	<-t.tick
	return retVar12
}

// Set is channeled
func (t *ChanTomates) Set(x []*Tomate) *Tomates {
	var retVar13 *Tomates
	t.ops <- func() {
		retVar13 = t.embed.Set(x)
	}
	<-t.tick
	return retVar13
}

// Get is channeled
func (t *ChanTomates) Get() []*Tomate {
	var retVar14 []*Tomate
	t.ops <- func() {
		retVar14 = t.embed.Get()
	}
	<-t.tick
	return retVar14
}

// At is channeled
func (t *ChanTomates) At(i int) *Tomate {
	var retVar15 *Tomate
	t.ops <- func() {
		retVar15 = t.embed.At(i)
	}
	<-t.tick
	return retVar15
}

// Filter is channeled
func (t *ChanTomates) Filter(filters ...func(*Tomate) bool) *Tomates {
	var retVar16 *Tomates
	t.ops <- func() {
		retVar16 = t.embed.Filter(filters...)
	}
	<-t.tick
	return retVar16
}

// Map is channeled
func (t *ChanTomates) Map(mappers ...func(*Tomate) *Tomate) *Tomates {
	var retVar17 *Tomates
	t.ops <- func() {
		retVar17 = t.embed.Map(mappers...)
	}
	<-t.tick
	return retVar17
}

// First is channeled
func (t *ChanTomates) First() *Tomate {
	var retVar18 *Tomate
	t.ops <- func() {
		retVar18 = t.embed.First()
	}
	<-t.tick
	return retVar18
}

// Last is channeled
func (t *ChanTomates) Last() *Tomate {
	var retVar19 *Tomate
	t.ops <- func() {
		retVar19 = t.embed.Last()
	}
	<-t.tick
	return retVar19
}

// Empty is channeled
func (t *ChanTomates) Empty() bool {
	var retVar20 bool
	t.ops <- func() {
		retVar20 = t.embed.Empty()
	}
	<-t.tick
	return retVar20
}
