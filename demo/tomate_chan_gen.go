package main

// file generated by
// github.com.mh-cbon/channeler
// do not edit

// ChanTomates is channeled.
type ChanTomates struct {
	embed *Tomates
	ops   chan func()
	stop  chan bool
}

// NewChanTomates constructs a chenneled version of *Tomates
func NewChanTomates() *ChanTomates {
	ret := &ChanTomates{
		ops:  make(chan func()),
		stop: make(chan bool),
	}
	ret.embed = NewTomates()
	go ret.Start()
	return ret
}

// Start the main loop
func (t *ChanTomates) Start() {
	for {
		select {
		case op := <-t.ops:
			op()
		case <-t.stop:
			return
		}
	}
}

// Stop the main loop
func (t *ChanTomates) Stop() {
	t.stop <- true
}

// Push is channeled
func (t *ChanTomates) Push(x ...*Tomate) *Tomates {
	var retVar0 *Tomates
	t.ops <- func() {
		retVar0 = t.embed.Push(x...)
	}
	return retVar0
} // Push appends every *Tomate

// Unshift is channeled
func (t *ChanTomates) Unshift(x ...*Tomate) *Tomates {
	var retVar1 *Tomates
	t.ops <- func() {
		retVar1 = t.embed.Unshift(x...)
	}
	return retVar1
} // Unshift prepends every *Tomate

// Pop is channeled
func (t *ChanTomates) Pop() *Tomate {
	var retVar2 *Tomate
	t.ops <- func() {
		retVar2 = t.embed.Pop()
	}
	return retVar2
} // Pop removes then returns the last *Tomate.

// Shift is channeled
func (t *ChanTomates) Shift() *Tomate {
	var retVar3 *Tomate
	t.ops <- func() {
		retVar3 = t.embed.Shift()
	}
	return retVar3
} // Shift removes then returns the first *Tomate.

// Index is channeled
func (t *ChanTomates) Index(s *Tomate) int {
	var retVar4 int
	t.ops <- func() {
		retVar4 = t.embed.Index(s)
	}
	return retVar4
} // Index of given *Tomate. It must implements Ider interface.

// Contains is channeled
func (t *ChanTomates) Contains(s *Tomate) bool {
	var retVar5 bool
	t.ops <- func() {
		retVar5 = t.embed.Contains(s)
	}
	return retVar5
} // Contains returns true if s in is t.

// RemoveAt is channeled
func (t *ChanTomates) RemoveAt(i int) bool {
	var retVar6 bool
	t.ops <- func() {
		retVar6 = t.embed.RemoveAt(i)
	}
	return retVar6
} // RemoveAt removes a *Tomate at index i.

// Remove is channeled
func (t *ChanTomates) Remove(s *Tomate) bool {
	var retVar7 bool
	t.ops <- func() {
		retVar7 = t.embed.Remove(s)
	}
	return retVar7
} // Remove removes given *Tomate

// InsertAt is channeled
func (t *ChanTomates) InsertAt(i int, s *Tomate) *Tomates {
	var retVar8 *Tomates
	t.ops <- func() {
		retVar8 = t.embed.InsertAt(i, s)
	}
	return retVar8
} // InsertAt adds given *Tomate at index i

// Splice is channeled
func (t *ChanTomates) Splice(start int, length int, s ...*Tomate) []*// Splice removes and returns a slice of *Tomate, starting at start, ending at start+length.
// If any s is provided, they are inserted in place of the removed slice.
Tomate {
	var retVar9 []*Tomate
	t.ops <- func() {
		retVar9 = t.embed.Splice(start, length, s...)
	}
	return retVar9
}

// Slice is channeled
func (t *ChanTomates) Slice(start int, length int) []*// Slice returns a copied slice of *Tomate, starting at start, ending at start+length.
Tomate {
	var retVar10 []*Tomate
	t.ops <- func() {
		retVar10 = t.embed.Slice(start, length)
	}
	return retVar10
}

// Reverse is channeled
func (t *ChanTomates) Reverse() *Tomates {
	var retVar11 *Tomates
	t.ops <- func() {
		retVar11 = t.embed.Reverse()
	}
	return retVar11
} // Reverse the slice.

// Len is channeled
func (t *ChanTomates) Len() int {
	var retVar12 int
	t.ops <- func() {
		retVar12 = t.embed.Len()
	}
	return retVar12
} // Len of the slice.

// Set is channeled
func (t *ChanTomates) Set(x []*// Set the slice.
Tomate) *Tomates {
	var retVar13 *Tomates
	t.ops <- func() {
		retVar13 = t.embed.Set(x)
	}
	return retVar13
}

// Get is channeled
func (t *ChanTomates) Get() []*// Get the slice.
Tomate {
	var retVar14 []*Tomate
	t.ops <- func() {
		retVar14 = t.embed.Get()
	}
	return retVar14
}

// At is channeled
func (t *ChanTomates) At(i int) *Tomate {
	var retVar15 *Tomate
	t.ops <- func() {
		retVar15 = t.embed.At(i)
	}
	return retVar15
} // At return the item at index i.

// Filter is channeled
func (t *ChanTomates) Filter(filters ...func(*Tomate) bool) *Tomates {
	var retVar16 *Tomates
	t.ops <- func() {
		retVar16 = t.embed.Filter(filters...)
	}
	return retVar16
} // Filter return a new Tomates with all items satisfying f.

// Map is channeled
func (t *ChanTomates) Map(mappers ...func(*Tomate) *Tomate) *Tomates {
	var retVar17 *Tomates
	t.ops <- func() {
		retVar17 = t.embed.Map(mappers...)
	}
	return retVar17
} // Map return a new Tomates of each items modified by f.

// First is channeled
func (t *ChanTomates) First() *Tomate {
	var retVar18 *Tomate
	t.ops <- func() {
		retVar18 = t.embed.First()
	}
	return retVar18
} // First returns the first value or default.

// Last is channeled
func (t *ChanTomates) Last() *Tomate {
	var retVar19 *Tomate
	t.ops <- func() {
		retVar19 = t.embed.Last()
	}
	return retVar19
} // Last returns the last value or default.

// Empty is channeled
func (t *ChanTomates) Empty() bool {
	var retVar20 bool
	t.ops <- func() {
		retVar20 = t.embed.Empty()
	}
	return retVar20
} // Empty returns true if the slice is empty.
